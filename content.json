{"meta":{"title":"西左Log","subtitle":"","description":"自是者不彰。","author":"西左","url":"https://dangyoo.github.io","root":"/"},"pages":[],"posts":[{"title":"鱼人宝宝都能看懂的Erupt实践攻略","slug":"鱼人宝宝都能看懂的Erupt实践攻略","date":"2023-03-30T08:17:16.000Z","updated":"2023-08-10T13:00:53.472Z","comments":true,"path":"2023/03/30/鱼人宝宝都能看懂的Erupt实践攻略/","link":"","permalink":"https://dangyoo.github.io/2023/03/30/%E9%B1%BC%E4%BA%BA%E5%AE%9D%E5%AE%9D%E9%83%BD%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84Erupt%E5%AE%9E%E8%B7%B5%E6%94%BB%E7%95%A5/","excerpt":"","text":"闲言碎语最近工作中需要实现一个简单的表单式呈现工具，主要用来展现一些元数据、业务流程数据，然后管理一些表和业务流程的关系等 主要需要的能力是能够做表单展示、能够编辑内容、能够数据互通（非手动） 本来考虑的是用鹅的微搭，结果搞了半天发现这东西主要是用来快速实现小程序的，其他东西就是做了个样子，数据导入导出API？那是什么东西？ 所以考虑其他工具，之前用过明道云，算是比较成熟且好用的产品了，可惜要花钱，不是我能决定的 之前搭过Django后台管理，实现过一些需求，不过这次领导推荐了Erupt，说自己玩过几次，那我也来玩玩 本地跑Demo第一步肯定是先在本地搭一个，然后再去服务器上搭（谁成想领导说你怎么不用Docker，要什么服务器） 官方文档 跟着官方的部署步骤进行操作 因为后续正式使用是用的MySQL，所以首先在本地装好MySQL，版本影响不大，但是8.0和常见5.0的语法不太一样MySQL安装，新建一个database以供项目使用，示例中用的是erupt 在Spring Initializr创建一个项目。这里左侧Project选择Maven，Language选择Java，Spring Boot选择2.7.12（暂时3.x的支持没有2.x的好），Java版本选17，然后下方选择GENERATE生成一个demo.jar压缩包并下载 解压缩，在IDEA中打开为Maven工程，这一步如果操作错了导致打开后IDEA右侧没有Maven选项，可以参考本文进行补救 有几个关键的文件，一个是pom.xml，在里边添加依赖包，例如erupt的UI页面包、用户权限包，或者Java连接MySQL的依赖包等；另一个是resources文件夹，里边存的是后面会用到的配置信息、静态文件等等资源 根据官方文档在pom.xml添加所需的依赖包，将示例中的$&#123;erupt.version&#125;改为具体的版本号如1.11.7 1234567&lt;!--例如一个MySQL5的依赖包--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.49&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 修改后会在IDEA右上角出现一个m字符的图标，点击Load Maven Changes，可以下载对应依赖包，快捷键是Command + Shift + I 根据官方文档在resources文件夹下新建public文件夹，并在其中添加app.js，app.css，home.html文件，按照示例（点击官方文档表格后边的#）复制内容进去 根据官方文档在resources文件夹下新建application.yml文件（properties应该也行但是我没成功），注意数据库链接中，示例的jdbc:mysql://127.0.0.1:3306/erupt中的erupt是事先建好的database 根据官方文档在Spring Boot入口类，也就是demo.src.main.java.com.example.demo.DemoApplication中，添加 @EntityScan、@EruptScan 注解，添加后如果IDEA中显示红色，则需要引入，鼠标放在红色上点击Import class即可，或者快捷键Alt + Shift + Enter 12import org.springframework.boot.autoconfigure.domain.EntityScan;import xyz.erupt.core.annotation.EruptScan; 运行DemoApplication，可以选择在左侧目录树右键选择Run，也可以在文件中运行main方法 启动后会自动在对应的database中新建一些表，然后在http://localhost:8080可以看到登录页，默认用户名密码都是erupt 过程中遇到什么问题优先查看官方Q&amp;A，搜索引擎搜到对应内容挺不容易，也可以考虑去B站看视频操作 数据表的创建按照官方入门示例开始通过创建Class来给数据库建表，并通过管理菜单绑定到页面上 在入口类同级别创建model文件夹，也就是demo.src.main.java.com.example.demo.model，用来存放所有会用到的Class，一个Class对应一个可以在管理菜单进行绑定的类型值 一些可能用到的语法，view和edit的各类配置项参考官方文档以及示例1234567private Long id; # 字段id的类型为Long@Lobprivate String comment; # 字段comment的类型为textviews = @View(title = &quot;名称&quot;, sortable = true) # 字段可以点击表头进行排序edit = @Edit(title = &quot;名称&quot;, readonly = @Readonly, search = @Search(vague = true)) # 字段不可编辑，可以进行模糊搜索（页面上方会有虚线搜索框，false为精确搜索，搜索框为实线） 部署本地把项目创建好并且导入部分数据玩熟了之后，开始考虑部署的问题，本来想着整个内部服务器上去操作以便就行了，但是领导非要让用Docker部署到k8s上，学吧有啥办法 啥是Docker虽然之前听说过这，大概有个印象是能做到环境隔离，然后能快速部署，具体怎么实现，完全不知道，参考文档学了半天基本搞明白怎么操作了 按照个人浅薄但够用的理解来说，Docker整个技术就是将某个应用所需的软件依赖编写在Dockerfile中，通过Docker引擎将所需的依赖打包到一个镜像image中，使得这个镜像可以在任何硬件上运行的过程 咋打包这个erupt项目首先这个项目本身需要打包成一个jar包，为了运行这个jar包，需要一个能够运行java的JDK，然后最底层需要一个linux操作系统 那对于Dockerfile来说，最先应该引入一个linux操作系统镜像，然后引入一个对应版本的JDK镜像，然后将这个项目的jar包导入，然后运行就好了 12345FROM xxx/jdk:17 # 这里先把linux+JDK打包成了一个镜像传到了仓库中MAINTAINER dangyooEXPOSE 8080ADD demo.jar /app.jar # 把本地的项目jar包导入ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] # 运行这个包 在把项目打包成demo.jar的时候，最好使用Maven工具进行，IDEA本身的built会有很多依赖冲突的问题，在打包前最好将测试跳过，否则会连接数据库，如果数据库配置的是内网数据库，就会连不上报错 跳过测试设置：Settings - Build, Execution, Deployment - Build Tools - Maven - Runner - Properties - Skip Tests打勾 使用Maven打包：右上角Maven - demo - Lifecycle - package 打包后默认文件路径是在demo/target/demo-0.0.1-SNAPSHOT.jar这里","categories":[{"name":"教程","slug":"教程","permalink":"https://dangyoo.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Erupt","slug":"Erupt","permalink":"https://dangyoo.github.io/tags/Erupt/"}]},{"title":"农历和阴历是啥关系","slug":"农历和阴历是啥关系","date":"2023-03-29T02:20:41.000Z","updated":"2023-08-10T13:00:53.472Z","comments":true,"path":"2023/03/29/农历和阴历是啥关系/","link":"","permalink":"https://dangyoo.github.io/2023/03/29/%E5%86%9C%E5%8E%86%E5%92%8C%E9%98%B4%E5%8E%86%E6%98%AF%E5%95%A5%E5%85%B3%E7%B3%BB/","excerpt":"","text":"闲言碎语快要清明节了，昨天闲聊突然想到，为啥清明节是阳历的4月5日，而其他很多传统节日又是阴历，比如七月初七啥的，按照未曾证实过的固有印象，中国古代用的农历就是现在的阴历，所以中国传统节日不都应该是阴历吗？ 遂查资料 为什么清明节是阳历清明节本来并不是传统节日，而是属于二十四节气之一，慢慢变成了节日，而二十四节气是依据古代的阳历划分的 节气 节气指二十四时节和气候，是中国古代用来指导农事之历法历注 中国传统夏历（农历）是一种“阴阳合历”，同时根据日、月运行制定，“阴”是以朔望月为基准确定，“阳”是以地球自冬至绕太阳公转一圈为基准确定岁实，每回归年约365.2422日，二十四节气据此而划分 所以古代的阳历是以地球公转周期（和太阳相关）制定的，而阴历是以月相制定的。由于太阳和农业之间的密切关系，阳历用来指导农业生产，确实理所应当。 古人将黄道划分4季，12节，24气，72候。定义3节为一季，约30日为一节，15日为一气，5日为一候。 清明：清明之日桐始华，又五日田鼠化为鴽，又五日虹始见。 清明是怎么从节气变为节日的 清明 传统寒食节、上巳节、清明节相距甚近，为了方便，往往连续假期，唐代时寒食与清明已并称，清明本无太多文化内涵，而寒食、上巳则传统丰厚，三相结合，便成了一个重要的节日。 寒食节 通常是冬至后第105日，与清明节日期相近，在清明节前一或二日。清初汤若望《时宪历》订定后，清明与冬至之间的间隔缩短，为了维持寒食节在清明节前一、两日的风俗，民间将寒食节定在清明节一日之前。现代24节气的定法沿袭汤氏，因此清明节就在寒食节次日。 一般认为寒食节是为了纪念介子推，寒食节的真正起源，是源于古代的钻木、求新火之制。古人因季节不同，用不同的树木钻火，有改季改火之俗。而每次改火之后，就要换取新火。新火未至，就禁止人们生火，这在当时是件大事。 据敦煌文献“进奏院状”载，晚唐时沙州赴京请旌节者称：“五日遇寒食，至八日假开。”即寒食清明休4天假。 上巳节 在汉代以前定为三月上旬的巳日，后来固定在农历三月初三。 相传三月三是黄帝、玄天上帝诞辰，也是哪吒太子升天日，还是中国神话中高媒神诞辰，高媒是媒人之神，可保佑媒人，亦可保佑男女恋爱顺利。高媒通说女娲，但尚有简狄、伏羲、勾芒等说法。 所以清明的扫墓是继承的寒食节习俗，踏青是继承的上巳节习俗，怎么没继承休假4天习俗呢。 公历？阳历？农历？阴历？农历属于阴阳合历，其中阴历根据月相制定，阳历根据太阳运行制定，并不是曾以为的农历&#x3D;阴历 阴阳合历 纯“阳历”是指历法中只保证一年的时间与地球绕日运行周期基本一致，不考虑月份，例如华夏24节气；纯“阴历”是指历法中只保证一个月的时间与月亮运行周期基本一致，不考虑年长；而阴阳历则既保证“多年的平均值”与地球绕日周期的一致，又保证“月”与月亮周期的一致。 采用阴阳合历的主要目的是配合季节，因此需要安排闰月来调整，大多数年份有12个朔望月，闰年就会有13个月。连续十九年为一章，其中安置七个闰月置闰，使历年的平均值大约与“地球公转一年”相当（大多采用回归年定义，也有采用恒星年定义者）。构成阴阳合历的历年连续19年一套可名为阴阳章历，四章连续一套为一蔀（详见史记历书），可名为阴阳蔀历。俗称农民历的夏历就是阴阳合历之一种。 因十九年七闰之规律，每个人在其19岁倍数之生日，有机会西历（公历）生日与夏历（农历）重合于同一日 阴阳合历制中单一一历年，其月数、日数不定。 农历 中华民国成立后，孙中山宣布以格里历作官方历法，称为国历、新历，华夏传统历法则返称旧历、传统历、古历。格里历为阳历，而农历是以月相周期安排月份之日期，故习称阴历。 也就是说，虽然农历在古代是一部阴阳合历，但到了民国之后，就叫”阴历”了，这时”阴历”的概念已经完全等于农历，且不等于农历中的”阴历”了 公历，也就是现在俗称的”阳历”，清朝称为”西历”，民国临时政府成立后对外改称”公历” 公历 公历，是当前国际通用的历法，也叫格里历。 1582年10月，教宗格勒哥里十三世介绍和引入这种历法，作为对儒略历的修改和替代。主要的变化是对闰年的加入进行了不同的划分，使平均行事历年长365.2425天，更接近由地球绕太阳公转决定的365.2422天的回归或太阳年。 总结农历是阴阳合历，农历中的阳历和当前的公历不完全相等，但都和太阳运行有关，所以按照农历中阳历制定的二十四节气和当前的公历相关，清明属于二十四节气融合了寒食节、上巳节后演变成的节日，与农历中的阳历相关，也就呈现出与公历相关的样子 农历中的阴历和当前的阴历不等，当前的阴历与农历相等，二十四节气属于农历中的内容，也就属于当前的阴历 其余与节气无关的中国传统节日，如春节、元宵节等，就是源于农历中的阴历部分，所以与当前的公历无关","categories":[{"name":"日常考据","slug":"日常考据","permalink":"https://dangyoo.github.io/categories/%E6%97%A5%E5%B8%B8%E8%80%83%E6%8D%AE/"}],"tags":[{"name":"常识","slug":"常识","permalink":"https://dangyoo.github.io/tags/%E5%B8%B8%E8%AF%86/"}]},{"title":"洋葱在烹饪中的作用","slug":"洋葱在烹饪中的作用","date":"2023-03-17T02:30:20.000Z","updated":"2023-08-10T13:00:53.472Z","comments":true,"path":"2023/03/17/洋葱在烹饪中的作用/","link":"","permalink":"https://dangyoo.github.io/2023/03/17/%E6%B4%8B%E8%91%B1%E5%9C%A8%E7%83%B9%E9%A5%AA%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/","excerpt":"","text":"闲言碎语昨天去吃俄士厨房，上来的几乎每道菜里都有或生或熟的洋葱，我说我不爱吃洋葱，路边炒面都不要洋葱 饭搭子们表示洋葱是烹饪中非常重要的一种食材，能发挥很多总用，但是具体作用是啥为啥发挥，说不出来 遂查资料 糖的作用模糊有影响之前在哪里看到过说洋葱受热分解可以产生糖，然后通过焦糖反应为食物增加风味 翻了翻之前买的《食物与厨艺：面食·酱料·甜点·饮料》，找到讲糖的那部分： 甜味的复杂作用 甜味是种单纯的感受，糖产生的甜味却不是这样。甜味有助于掩盖或平衡其他成分带来的酸味和枯萎。风味化学家也已经发现，甜味能大幅提升我们对食物香气的感受，甜味也有可能对脑部发出讯号，提示这种食物是优异的能源，有必要特别注意。 不同的糖类会带来不同的甜味印象。舌头要花点时间才能对蔗糖产生反应，尝到的甜味会萦绕多时。相对而言，果糖的甜味很快就能察觉，讯号很强却也很快消退。玉米糖浆的甜味则要很久才能尝出，最甜时，强度约为蔗糖的一般，味道残留时间则比蔗糖更久。据称果糖这种高速反应还能强化食品的其他集中供暖风味，特别是果味、酸味和香料味，这是由于果糖不留余味，不会把其他味道盖掉，而能让我们清楚品尝到。 焦糖化反应 “焦糖化”是指糖类受热超过特定温度，分子开始瓦解产生的化学反应，适用于所有糖类。分子毁损会触发一连串化学反应，产生美妙的产物。厨师从单一种类分子入手，将无色无味的单纯甜味晶体料理成好几百种不同成分的新颖化合物，其中有些是带了酸味、苦味，甚至能散发强烈香气的小碎片；有些则是不带风味，却呈现深褐色的大型凝聚体。糖烧煮越久，残留的甜味越少，颜色越深，味道也越苦。 焦糖化反应产生的风味 糖受热之后，原本没有气味的单糖类甜分子便转化成好几百种不同的分子，散发出繁复风味，展现深褐色泽。其中集中带芳香气味的产物为：酒精、带雪利酒味的乙醛、带醋味的乙酸、带奶油味的醋双乙酰、带果味的乙酸乙酯、带坚果味的呋喃、具溶剂作用的苯、带有烘烤味的麦芽醇。 那如果说洋葱受热产生了糖，就可以用糖的作用来解释洋葱的作用，那接下来就是查一下洋葱是怎么受热产生糖的 洋葱味道的产生查一下洋葱为什么炒了之后会变甜，有些文章提到，洋葱中含有蔗糖，所以是蔗糖的焦糖化反应是风味的一种产出原因，除此之外，也有文章提到，炒洋葱的甜味主要是美拉德反应（又称梅纳反应）造成的 美拉德反应 指的是食物中的还原糖（碳水化合物）与氨基酸／蛋白质在常温或加热时发生的一系列复杂反应，其结果是生成了棕黑色的大分子物质类黑精或称拟黑素。除产生类黑精外，反应过程中还会产生成百上千个有不同气味的中间体分子，包括还原酮、醛和杂环化合物，这些物质为食品提供了宜人可口的风味和诱人的色泽。它以法国化学家路易斯·卡米拉·美拉德命名，他在1912年首次描述它，同时试图重现生物蛋白质合成。美拉德反应的产物中，包含颜色的变黄变深变黑、香气的产生、以及味道上的转变，例如甜味的产生。该反应是一种非酶促褐变的形式，其通常快速从约140摄氏度至170摄氏度中进行。在较高的温度下，焦糖化和随后的裂解变得更加明显。在此过程中，产生了数百种不同的风味化合物。这些化合物又分解成形成更多新的风味化合物等等。 梅納反應跟焦糖化到底差在哪？一次搞懂原理與五種實用範例 美拉德反应除了会产生焦糖化反应的风味之外，还会产生诸如香咸、花香、肉香、巧克力、蔬菜、土豆和泥土味。 虽然洋葱确实含有天然蔗糖，烹煮时有助于产生金黄色泽与甜味，因此也存在焦糖化。但主要的褐变原因还是來自加热蛋白质与还原糖所致。当洋葱丝遇热，表面水分就开始蒸发，颜色渐转焦褐，数以百计的风味分子释出。 美中食材的风味组成差异显著，视各种氨基酸的多寡占比而定。在炒焦化洋葱时，也可以加上些许苏打粉提升PH值，咸性会加强梅纳反应。 什么是美拉德反应? 美拉德反应初期阶段反应包括还原糖的羰基碳首先遭到氨基氮上孤对电子的亲核加成，接着失去水和闭环二形成葡基胺，如果还有过量的还原糖存在，就能进一步形成二葡基胺。葡基胺再经过阿马道里重排而生成1－氨基－2－酮糖。美拉德反应初级阶段不引起褐变，也不产生香味，但其产物是产生极重要的不挥发性香味物质的前驱物。 在氨基酮糖和氨基醛糖等重要的不挥发性香味前驱物形成之后，美拉德反应变得更为复杂，阿马道里重排产物经过－消去机理脱水，在经过脱水脱掉氨基而生成3－脱氧己糖醛酮、奥苏烯糖和HMF 等，这些不同的化合物依次反应，开始形成无氮及含氮褐色可溶性化合物。 高级美拉德反应阶段形成的众多活性中间体如葡萄糖酮醛、3－脱氧、3,4－二脱氧、HMF、二还原酮类、不饱和醛亚胺等等，又可继续与氨基酸反应，最终生成类黑精色素，褐色含氮色素，吡嗪和咪唑环等风味物质。此过程包括醇醛缩合、醛氨聚合、环化合反应等。 在查洋葱时，很多文章都提到了”硫化物”，例如： 为什么西餐离不开洋葱，中餐里却毫无地位，没法和辣椒番茄比？ 洋葱具有辛辣味，是因为它拥有一些含硫物质，但进过充分加热，含硫化合物发生降解，降解之后的丙硫醇就有很好的甜味。所以吃生洋葱是为了辛辣，熟吃则是为了一口清甜味。 丙硫醇具有甜味？在维基百科查到的丙硫醇具有两种异构体，分别是正丙硫醇和异丙硫醇，正丙硫醇是一种无色液体，易挥发，具有臭鼬鼠味，而异丙硫醇是一种闪点易燃的无色液体，具有挥发性，微量具有臭味，对身体有害，大量吸入会引起嗅觉丧失、肌无力等症状。口服引起恶心、呕吐。对眼和皮肤有刺激性。怎么看也和甜味没啥关系。 再搜”硫化物受热降解”，搜到了一篇文章6类常见食品中含硫化合物风味特征及形成机理研究进展 挥发性含硫化合物广泛存在于多种食品中，具有阈值极低的特点，是对食品感官品质有重要贡献的特征风味组分，在形成食品独特风味特征中也起着至关重要的作用。不同种类的含硫化合物表现出的食品风味特征不尽相同，不同含量的含硫化合物对食品感官品质的影响也差异显著，因此，对感官风味受含硫化合物影响较大的6类常见食品中含硫化合物风味特征及其形成机理进行了研究。 二丙基二硫醚、二甲基三硫醚和大蒜素分别为大葱、洋葱和大蒜风味形成的关键含硫化合物 鲜菜类调味品呈现出来的独特味道大多来自于含硫化合物，而含硫化合物是来自于前体物质含硫氨基酸。蒜氨酸是大蒜中甲基烯丙基硫醚等含硫化合物的前体物质，S-烷基-L-半胱氨酸亚砜是洋葱中含硫化合物的前体物质。完整的大蒜是没有气味的，蒜氨酸和蒜氨酸酶分别稳定地处于细胞质和液泡2个不同的细胞器中，当大蒜破碎后蒜氨酸酶被释放，蒜氨酸在蒜氨酸酶的作用下形成大蒜素，随后大蒜素降解为其他的挥发性含硫化合物。洋葱中风味物质的形成与大蒜类似，只有当洋葱被破坏后其中的前体物质S-烷基-L-半胱氨酸亚砜被释放，在蒜氨酸酶的作用下产生洋葱的特征风味物质。 含硫化合物在洋葱中表现出明显的辛辣味和洋葱味，且含硫化合物占洋葱中检测到的挥发性化合物的一半以上。洋葱中主要的含硫化合物有甲硫醇、二丙基二硫醚、二丙基三硫醚、烯丙硫醇、丙硫醇、二甲基二硫醚、二甲基三硫醚、甲基乙基二硫醚、甲基丙基二硫醚、甲基丙烯基二硫醚、1-巯基丙烷、1,3-二噻烷、1,4-二噻烷、2,4-二甲基噻吩、3,4-二甲基噻吩、3-巯基-2-甲基戊醛。王依春等应用固相微萃取和同时蒸馏萃取这2种萃取方法，共检测到52种挥发性化合物，其中含硫化合物占70%左右，主要是一些硫醇和硫醚类的含硫化合物，包括甲硫醇、烯丙硫醇、丙硫醇、二甲基二硫醚、甲基乙基二硫醚、二甲基三硫醚、二丙基二硫醚、二丙基三硫醚等。孙雪君等对不同品种的干洋葱和鲜洋葱中的挥发性化合物进行分析后共检测到16种含硫化合物，主要包括1-巯基丙烷、二甲基三硫醚、甲基丙基二硫醚、二丙基二硫醚、1,3-二噻烷和2,4-二甲基噻吩。研究发现鲜洋葱比干洋葱含有更多的含硫化合物，这也是鲜洋葱味道更加辛辣、刺鼻的主要原因。 这里主要提到，新鲜的洋葱所表现出的味道，是由含硫氦基酸释放的，而含硫氨基酸，是由前体物质形成的。 细胞组织被破坏后,含硫氦基酸的前体物质(S-烷基-1-半胱氨酸亚砜、蒜氨酸等）被释放，在蒜氨酸酶的作用下形成。","categories":[{"name":"日常考据","slug":"日常考据","permalink":"https://dangyoo.github.io/categories/%E6%97%A5%E5%B8%B8%E8%80%83%E6%8D%AE/"}],"tags":[{"name":"烹饪","slug":"烹饪","permalink":"https://dangyoo.github.io/tags/%E7%83%B9%E9%A5%AA/"}]},{"title":"鱼人宝宝都能看懂的个人博客搭建攻略","slug":"鱼人宝宝都能看懂的个人博客搭建攻略","date":"2023-03-09T07:17:10.000Z","updated":"2023-08-12T09:02:07.646Z","comments":true,"path":"2023/03/09/鱼人宝宝都能看懂的个人博客搭建攻略/","link":"","permalink":"https://dangyoo.github.io/2023/03/09/%E9%B1%BC%E4%BA%BA%E5%AE%9D%E5%AE%9D%E9%83%BD%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%94%BB%E7%95%A5/","excerpt":"","text":"闲言碎语最近心血来潮，想把自己的知识库迁移到一个统一的地方。 之前用过一段时间语雀，在线编辑实在是有点卡，用了一年放弃了。 后来改用 Notion，操作非常方便，但是页面多起来以后，时常卡顿。 另外这类应用都把内容存到了服务器上，说实话没有本地备份还是有些不放心的。 考虑到主要目的是将知识库做好分类，并且保存到一个看起来不太会丢的地方，不需要各种各样的多媒体内容，大多是文字的东西，好像建个站更方便一些。 技术选型首先没有什么经验，先上知乎搜了下大概的技术类型，这篇文章讲的比较详细 静态博客技术选型最佳实践 根据需求，不考虑整域名和服务器，使用最快速的方法，毕竟内容更重要是吧，所以选定免费且用的人多所以教程丰富的 GitHub Pages + Hexo 配置和安装GitHub PagesGithub Pages 主要完成两个任务，一是存放内容，二是提供网页服务 Github Pages官方介绍 首先注册 github 账号，然后在主页 new 一个 repository，在 Repository name 一栏填写 username.github.io 这个username必须和你的账户名一致，如果账户名有大写字母，这里改为小写字母即可 底下的 Add a README file 最好选中，这样会直接创建一个主分支，如果没有文件的话仓库是没有分支的 创建好后进入对应 Repository，点击 Setting，侧边栏找到 Pages，设置好默认的分支 到这里 Github 上就已经操作好啦，这个 Repository 里存的就是你要对外呈现的内容，域名为 username.github.io Hexo由于 GitHub Pages 存放的都是静态文件，正常的博客存放的除了文章内容之外，还有文章列表、文章分类、文章标签等动态内容 这部分我们就可以用 Hexo 来完成 Hexo自称是一个快速、简洁且高效的博客框架，能够解析 Markdown 文章并生成静态页面 也就是能够解决文章列表、文章分类、文章标签等动态内容和文章页面的生成，我们只需要将文章内容提交到 GitHub 即可 Hexo官网 安装 Hexo 的前置任务是安装 Node.js 和 Git Node.js下载 Git下载 安装好 Node.js 后就可以使用 npm 来做 Hexo 的安装 npm install -g hexo 安装好后，在想要的根目录下运行以下命令进行初始化，我这里的根目录是 ./Blog hexo init 初始化后会生成一系列文件夹和文件，其中比较重要的是以下几个 _config.yml 配置文件，站点名字、主题、链接啥的都在这里改 themes 存储页面主题的文件夹，站点好看不好看就靠它 source 存储用户资源，比如文章内容、图片等 source&#x2F;_posts 存储文章内容 此时就可以对站点进行本地预览 hexo s 在浏览器中进入 http://localhost:4000/ 就能看到默认主题的网页啦 把 Hexo 和 Github Pages 结合起来修改 _config.yml 文件的内容，在文件最后找到 deploy，修改下面的内容，注意每一行英文分号后边的空格不要删掉 type: git repo: https://github.com/username/username.github.io branch: main repo 中的 username 需要替换为自己的账户名称 branch 和你在 GitHub Pages - Settings - Pages 中设置的分支一致 设置后在根目录执行命令 hexo clean hexo g &#x2F;&#x2F; 生成目录 hexo d &#x2F;&#x2F; 同步 Git 如果发生 ERROR Deployer not found: git 错误，则执行 npm install hexo-deployer-git –save 之后等一会儿就可以通过域名 username.github.io 在线访问博客了 常用操作新建一篇文章 hexo n “文章标题” 之后在任意编辑器中对文章进行编辑即可 美化Hexo 的页面美化是通过主题 theme 来实现的，在 _config.yml 文件可以看到一个 theme 项，默认值为 landscape，可以下载各种各样的主题来进行美化 比如本站用的就是 next 这个主题，另外常见的还有 butterfly 等主题 Hexo主题库 下载主题举例 butterfly 主题的下载和使用 首先在根目录下载主题到 themes 文件夹 git clone -b master https://gitee.com/immyw/hexo-theme-butterfly.git themes&#x2F;butterfly git clone https://github.com/theme-next/hexo-theme-next themes&#x2F;next git clone https://github.com/litten/hexo-theme-yilia.git themes&#x2F;yilia 然后修改 _config.yml 文件的 theme 值为 butterfly&#x2F;next&#x2F;yilia 即可 在文章中添加图片通过在 source 文件夹下新建存储图片的文件夹，如 images 然后将所需要的图片放在 images 文件夹下 在文章中使用 ![img](/images/a.jpg) 即可 如果需要调整图片大小，可以直接使用 HTML 的 img 标签 &lt;img src=&quot;/images/a.jpg&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt; 隐藏文章当一篇文章被设置为「隐藏」时，它不会出现在任何列表中（包括首页、存档、分类页面、标签页面、Feed、站点地图等），也不会被搜索引擎索引（前提是搜索引擎遵守 noindex 标签） npm install hexo-hide-posts –save 如果安装过程中出现 run npm audit fix to fix them, or npm audit for details 提示，尝试运行 npm audit fix npm set audit false 在 _config.yml 中添加如下设置 12345678910# hexo-hide-postshide_posts: # 可以改成其他你喜欢的名字 filter: hidden # 指定你想要传递隐藏文章的位置，比如让所有隐藏文章在存档页面可见 # 常见的位置有：index, tag, category, archive, sitemap, feed, etc. # 留空则默认全部隐藏 public_generators: [] # 为隐藏的文章添加 noindex meta 标签，阻止搜索引擎收录 noindex: true 在想要隐藏的文章中，添加 hidden 属性 12345---title: &#x27;Hidden Post&#x27;date: &#x27;2021/03/05 21:45:14&#x27;hidden: true--- 换台电脑继续建站在公司使用电脑A搭好以后，回家想用电脑B继续写文章，结果发现 hexo d 传到 Git 上的是已经解析好的静态网页文件，也就是只有 public 文件夹中的东西，其他属于 hexo 框架的部分都没有上传 所以需要把框架内容也同步到 Git 上，换电脑之后 pull 到本地继续编辑 在 Git 上另外建一个分支 hexo，与静态文件所在的分支分开，并将 hexo 分支设为 default 在本地原本根目录 ./Blog 之外的地方，重新 git clone 这个 hexo 分支，例如 hexo 分支目录为 ./hexo 清空 ./hexo 中的内容，把 ./Blog 目录中的内容复制到./hexo 中 运行 git add . git commit -m &quot;hexo框架&quot; git push，将内容更新到 hexo 分支 这样 Git 项目上，两个分支就分别为 hexo 框架内容 和 博客网页内容 了，以上的操作都发生在电脑A 换新电脑B之后，先安装 Node.js 和 git 然后 git clone hexo 分支，就可以直接进行博客编辑了，由于配置文件 _config.yml 中跟踪的分支是静态文件分支 main，所以使用 hexo d 提交时也会把内容提交到 main 分支 每次在电脑B或电脑A编辑之后，除了使用 hexo d 提交网页内容外，还要记得使用 git push 提交更新后的框架内容 使用遇到的问题 提示“无法加载文件hexo.ps1，因为在此系统上禁止运行脚本转载” 是Windows10下的策略设置问题，用管理员方式打开PowerShell（搜索PowerShell后选择管理员打开）并执行 set-ExecutionPolicy RemoteSigned 输入Y 即可 提示“Cannot find module ‘hexo’ from…” 安装包的问题，可能是误删了什么地方的东西，运行 npm install hexo –save 即可 hexo g后提示“NO LAYOUT” 确认主题是否还在themes文件夹下，可能被误删了 参考文章快速搭建个人博客 —— 保姆级教程 Hexo建站手册（详细教程） 有哪些好看的 Hexo 主题 Hexo 添加图片——不用插件，超简单 How to fix npm vulnerabilities manually NexT使用文档","categories":[{"name":"教程","slug":"教程","permalink":"https://dangyoo.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://dangyoo.github.io/tags/HEXO/"}]},{"title":"鱼人宝宝都能看懂的CDC知识","slug":"鱼人宝宝都能看懂的CDC知识","date":"2022-08-25T09:06:03.000Z","updated":"2023-08-12T13:24:29.097Z","comments":true,"path":"2022/08/25/鱼人宝宝都能看懂的CDC知识/","link":"","permalink":"https://dangyoo.github.io/2022/08/25/%E9%B1%BC%E4%BA%BA%E5%AE%9D%E5%AE%9D%E9%83%BD%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84CDC%E7%9F%A5%E8%AF%86/","excerpt":"","text":"闲言碎语在上家公司（代称N司）时，遇到一个情况：由于传统行业对数据资产的重视程度不够（也可能是安全意识较强），所有开发在数据库进行删除操作时，都是用的真删除，而非互联网公司常见的伪删除。这就造成，数据仓库每天同步全量数据的话，可能会发生主键丢失的情况，同时由于数据库设计以及不同系统间数据不通等各种问题，下游使用数据时就会出现准确性被质疑的情况。 在伪删除方案无法推动的情况下，数据侧考虑获取业务数据库的修改日志，来补齐这部分被删除的信息，所以就去研究了一下常见的方案。 啥叫CDCCDC全称是Change Data Capture，即变更数据捕获，它是数据库领域常见的技术，主要用于捕获数据库的一些变更，然后把变更数据发送到下游。它的应用比较广，可以做一些数据同步、数据分发和数据采集，还可以做ETL。 CDC的类型业界主要分为两种： 基于查询，客户端会通过SQL方式查询源库表变更数据，然后对外发送。这类技术是入侵式的，需要在数据源执行SQL语句，使用这种技术实现CDC会影响数据源的性能，通常需要扫描包含大量记录的整个表。常见工具有Sqoop&#x2F;DataX&#x2F;Kafka JDBC Source。 基于日志，这也是业界广泛使用的一种方式，一般是通过binlog方式。变更的记录会写入binlog，解析binlog后会写入消息系统，或直接基于Flink CDC进行处理。这种技术是非入侵性的，不需要在数据源执行SQL语句，通过读取源数据库的日志文件以识别对源库表的创建&#x2F;修改或删除数据。常见工具有Debezium&#x2F;Canal&#x2F;Maxwell。 DataXDataX是阿里巴巴开源的一个异构数据源离线同步工具，实现包括 MySQL、Oracle、SqlServer、Postgre、HDFS、Hive、ADS、HBase、TableStore(OTS)、MaxCompute(ODPS)、DRDS等各种异构数据源之间高效的数据同步功能。 异构数据源离线同步指的是将源端数据同步到目的端，但是端与端的数据源类型种类繁多，在没有DataX之前，端与端的链路将组成一个复杂的网状结构，非常零散无法把同步核心逻辑抽象出来。 为了解决异构数据源同步问题，DataX将复杂的网状的同步链路变成了星型数据链路，DataX作为中间传输载体负责连接各种数据源。 所以，当需要接入一个新的数据源的时候，只需要将此数据源对接到DataX，就可以跟已有的数据源做到无缝数据同步。 DataX本身作为离线数据同步框架，采用Framework+plugin架构构建。将数据源读取和写入抽象成为Reader&#x2F;Writer插件，纳入到整个同步框架中。 Reader：数据采集模块，负责采集数据源的数据，将数据发送给Framework。 Writer：数据写入模块，负责不断向Framework取数据，并将数据写入到目的端。 Framework：它用于连接Reader和Writer，作为两者的数据传输通道，并处理缓冲、并发、数据转换等问题。 核心模块DataX完成单个数据同步的作业，我们把它称之为Job，DataX接收到一个Job之后，将启动一个进程来完成整个作业同步过程。 DataX Job启动后，会根据不同的源端切分策略，将Job切分成多个小的Task(子任务)，以便于并发执行。 切分多个Task之后，DataX Job会调用Scheduler模块，根据配置的并发数据量，将拆分成的Task重新组合，组装成TaskGroup（任务组）。每一个TaskGroup负责以一定的并发运行完毕分配好的所有Task，默认单个任务组的并发数量为5。 每一个Task都由TaskGroup负责启动，Task启动后，会固定启动Reader-&gt;Channel-&gt;Writer的线程来完成任务同步工作。 DataX作业运行完成之后，Job监控并等待多个TaskGroup模块任务完成，等待所有TaskGroup任务完成后Job成功退出。否则，异常退出。 调度流程举例来说，用户提交了一个DataX作业，并且配置了20个并发，目的是将一个100张分表的MySQL数据同步到ODPS里面。 DataX的调度决策思路是： DataX Job根据分库分表切分成了100个Task。 根据20个并发，DataX计算共需要分配4个TaskGroup。 4个TaskGroup平分切分好的100个Task，每一个TaskGroup负责以5个并发共计运行25个Task。 优化常用的优化参数有：Channel（通道）&#x2F;SplitPk（切片）&#x2F;BatchSize（批数据大小） Channel - 通道，并发量，该设置对传输效率影响较为明显，设置为1时，即没有并发，此时同步速度均为8.9M&#x2F;s，将该设置调高之后，速率明显倍增，但增大到一定程度后，瓶颈就转到其他配置了。 SplitPk - 切片，MySQLReader进行数据抽取时，如果制定SplitPk，表示用户希望使用SplitPk代表的字段进行数据分片，DataX因此会启动并发任务进行数据同步，这样可以大大提高数据同步的效能。推荐SplitPk使用表主键，因为表主键通常情况下比较均匀，因此切分出来的分片也不容易出现数据热点。目前SplitPk仅支持整型数据切分，不支持浮点&#x2F;字符串&#x2F;日期等其他类型。如果用户指定其他非支持类型，MySQLReader将报错。如果SplitPk不填写，DataX视作使用单通道同步该表数据，并发需要与Channel设置配合。 BatchSize - 批数据大小，一次性批量提交的记录数大小，该值可以极大减少DataX与MySQL的网络交互次数，并提升整体吞吐量，默认为1024MB，过大可能会造成DataX运行进程OOM。 优缺点Datax的优势非常明显： 首先，部署非常简单，无论是在物理机上或者虚拟机上，只要网络通畅，便可进行数据同步，给实施人员带来了极大的便利，不受标准数据同步产品部署的条框限制 再者，它是开源产品，几乎没有成本但是，它的缺点也是显而易见的： 开源工具更多的是提供基础能力，并不具备任务管理，进度跟踪、校验等等一系列的功能，只能使用者自己通过脚本或者表格记录 单机部署，不提供分布式方案，需要通过调度系统解决 Debezium当一个应用程序将数据写入到数据库时，变更会被记录在日志文件中，然后数据库的表才会被更新。对于MySQL来说，日志文件是binlog；对于PostgreSQL来说，是write-ahead-log；而对于MongoDB来说，是op日志。Debezium有针对不同数据库的连接器，所以它能完全理解所有这些日志文件格式的艰巨工作。Debezium可以读取日志文件，并产生一个通用的抽象事件到消息系统中，如Apache Kafka，其中会包含数据的变化。 CanalCanal是阿里开源的一款基于MySQL数据库的binlog增量订阅和消费组件，通过它可以订阅数据库的binlog日志，然后进行一些数据消费，如数据镜像、数据异构、数据索引、缓存更新等。相对于消息队列，通过这种机制可以实现数据的有序化和一致性。 Canal模拟MySQL slave与MySQL master的交互协议，伪装自己是一个MySQL slave，向MySQL master发送dump协议。MySQL master收到dump请求，开始推送binlog增量日志给Canal。Canal收到binlog增量日志后，就可以对这部分日志进行解析，获取主库的结构及数据变更。再发送到存储目的地。 BinlogMySQL日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中比较重要的就是二进制日志binlog（归档日志）、事务日志redo log（重做日志）和undo log（回滚日志）。 redo log（重做日志）是InnoDB存储引擎独有的，它让MySQL有了崩溃恢复的能力。当MySQL实例挂了或者宕机了，重启的时候InnoDB存储引擎会使用rede log日志恢复数据，保证事务的持久性和完整性。 binlog（归档日志）是逻辑日志，记录内容是语句的原始逻辑，属于MySQL Server层。所有的存储引擎只要发生了数据更新，都会产生binlog日志。MySQL数据库的数据备份、主备、主主、住从都离不开binlog，需要依赖binlog来同步数据，保证数据一致性。Binlog是记录所有数据库表结构变更以及表数据修改的二进制日志，不会记录SELECT和SHOW这类操作。Binlog日志是以事件形式记录，还包含语句所执行的消耗时间。 想要保证事务的原子性，就需要在发生异常时，对已经执行的操作进行回滚，在MySQL中恢复机制是通过undo log（回滚日志）实现的，所有事务进行的修改都会先被记录到这个回滚日志，然后再执行其他相关的操作。如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子。并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。 使用场景 主从复制：在主库中开启Binlog功能，这样主库就可以把Binlog传递给从库，从库拿到Binlog后实现数据恢复达到主从数据一致性。 数据恢复：通过mysqlbinlog工具来恢复数据。 记录模式Binlog文件名默认为“主机名_binlog-序列号”格式，例如oak_binlog-000001，也可以在配置文件中指定名称。文件记录模式有STATEMENT、ROW和MIXED三种，具体含义如下： STATEMENT（statement-based replication, SBR） - 每一条被修改数据的SQL都会记录到master的Binlog中，slave在复制的时候SQL进程会解析成和原来master端执行过的相同的SQL再次执行。简称SQL语句复制。比如执行一条update T set update_time &#x3D; now() where id &#x3D; 1，记录内容如下： 优点：日志量小，减少磁盘IO，提升存储和恢复速度 缺点：在某些情况下会导致主从数据不一致，比如last_insert_id()、now()等函数 ROW（row-based replication, RBR） - 日志中会记录每一行数据被修改的情况，然后在slave端对相同的数据进行修改。同一句SQL，记录内容如下： 优点：能清楚记录每一个行数据的修改细节，能完全实现主从数据同步和数据的恢复 缺点：批量操作，会产生大量的日志，尤其是alter table会让日志暴涨 MIXED（mixed-based replication, MBR） - 以上两种模式的混合使用，一般会使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择写入模式。例如上述SQL如果记录未STATMENT模式会由于now()造成数据不一致，所以会记录未MIXED格式。 写入机制binlog的写入时机为事务执行过程中，先把日志写到binlog cache，事务提交的时候再把binlog cache写到binlog文件中（实际先会写入page cache，然后再由fsync写入binlog文件）。 因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一块内存作为binlog cache。可以通过binlog_cache_size参数控制单线程binlog_cache大小，如果存储内容超过了这个参数，就要暂存到磁盘。 上图的write，是指把日志写入到文件系统的page cache，并没有把数据持久化硬盘，所以速度比较快。 上图的 fsync才是将数据库持久化到硬盘的操作。 write和fsync的时机可以由参数sync_binlog控制，可以配置成0、1、N(N&gt;1)。 设置成0时：表示每次提交事务都只会write，由系统自行判断什么时候执行fsync。 设置成1时：表示每次提交事务都会执行fsync，就和redo log日志刷盘流程一样。 设置成N时：表示每次提交事务都会write，但是积累N个事务后才fsync。 操作代码1234567891011121314151617181920212223242526272829303132333435363738394041-- binlog状态查看show variables like &#x27;log_bin&#x27;;-- 开启Binlog功能，需要需改my.cnf或my.ini配置文件，在mysqld下面增加log_bin=mysql_bin_log，重启MySQL服务#log-bin=ON #log-bin-basename=mysqlbinlog binlog-format=ROW log-bin=mysqlbinlog-- 执行开启语句set global log_bin=mysqllogbin; -- 使用show binlog event命令show binary logs; //等价于show master logs; show master status; show binlog events; show binlog events in &#x27;mysqlbinlog.000001&#x27;\\G;结果: Log_name: mysql_bin.000001 //此条log存在那个文件中 Pos: 174 //log在bin-log中的开始位置 Event_type: Intvar //log的类型信息 Server_id: 1 //可以查看配置中的server_id,表示log是那个服务器产生 End_log_pos: 202 //log在bin-log中的结束位置 Info: INSERT_ID=2 //log的一些备注信息，可以直观的看出进行了什么操作 -- 可以用mysql自带的工具mysqlbinlogmysqlbinlog &quot;文件名&quot; mysqlbinlog &quot;文件名&quot; &gt; &quot;文件名比如:test.sql&quot; -- 使用binlog恢复数据// 按指定时间恢复 mysqlbinlog --start-datetime=&quot;2020-04-25 18:00:00&quot; --stop-datetime=&quot;2020-04-26 00:00:00&quot; mysqlbinlog.000002 | mysql -uroot -p1234 // 按事件位置号恢复 mysqlbinlog --start-position=154 --stop-position=957 mysqlbinlog.000002 | mysql -uroot -p1234// mysqldump：定期全部备份数据库数据// mysqlbinlog: 可以做增量备份和恢复操作-- 删除binlog文件purge binary logs to &#x27;mysqlbinlog.000001&#x27;; // 删除指定文件 purge binary logs before &#x27;2020-04-28 00:00:00&#x27;; // 删除指定时间之前的文件 reset master; // 清除所有文件// 可以通过设置expire_logs_days参数来启动自动清理功能// 默认值为0表示没启用。设置为1表示超出1天binlog文件会自动删除掉 Redo Log和Binlog的区别 Redo Log是属于InnoDB引擎功能，Binlog是属于MySQL Server自带功能，并且是以二进制文件记录。 Redo Log属于物理日志，记录该数据页更新状态内容，Binlog是逻辑日志，记录更新过程。 Redo Log日志是循环写，日志空间大小是固定，Binlog是追加写入，写完一个写下一个，不会覆盖使用。 Redo Log作为服务器异常宕机后事务数据自动恢复使用，Binlog可以作为主从复制和数据恢复使用。Binlog没有自动crash-safe能力。 crash-safe即在InnoDB 存储引擎中，事务提交过程中任何阶段，MySQL突然奔溃，重启后都能保证事务的完整性，已提交的数据不会丢失，未提交完整的数据会自动进行回滚。这个能力依赖的就是redo log和undo log两个日志 参考文章DataX入门Debezium入门Canal入门","categories":[{"name":"知识","slug":"知识","permalink":"https://dangyoo.github.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Data","slug":"Data","permalink":"https://dangyoo.github.io/tags/Data/"}]}],"categories":[{"name":"教程","slug":"教程","permalink":"https://dangyoo.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"日常考据","slug":"日常考据","permalink":"https://dangyoo.github.io/categories/%E6%97%A5%E5%B8%B8%E8%80%83%E6%8D%AE/"},{"name":"知识","slug":"知识","permalink":"https://dangyoo.github.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Erupt","slug":"Erupt","permalink":"https://dangyoo.github.io/tags/Erupt/"},{"name":"常识","slug":"常识","permalink":"https://dangyoo.github.io/tags/%E5%B8%B8%E8%AF%86/"},{"name":"烹饪","slug":"烹饪","permalink":"https://dangyoo.github.io/tags/%E7%83%B9%E9%A5%AA/"},{"name":"HEXO","slug":"HEXO","permalink":"https://dangyoo.github.io/tags/HEXO/"},{"name":"Data","slug":"Data","permalink":"https://dangyoo.github.io/tags/Data/"}]}